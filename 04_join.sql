
-- JOIN

-- 1, CROSS JOIN

-- CROSS JOIN의 결과와 같은 행수 조회
SELECT COUNT(*) FROM EMP, DEPT;

SELECT (SELECT COUNT(*) FROM EMP) * (SELECT COUNT(*) FROM DEPT) FROM DUAL;

-- 2. EQUI JOIN

-- 직원 테이블에 신입사원 레코드 등록: 사번 7777, 이름 홍길동, 입사일 현재날짜, 급여 4000
DESC EMP;
INSERT INTO EMP VALUES(7777, '홍길동', NULL, NULL, SYSDATE, 4000, NULL, NULL);
SELECT * FROM EMP;

-- 부서 테이블 구조 조회
DESC DEPT;

-- 직원의 부서번호, 부서명, 부서위치, 사번, 이름 정보를 조회 : 조인(직원의 부서번호 => 부서테이블 부서번호)
SELECT EMP.DEPTNO, DNAME, LOC, EMPNO, ENAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMP.DEPTNO;

-- 3. OUTER JOIN
-- 누락된 데이터 조회
-- 부서원이 없는 부서번호 조회
SELECT DISTINCT DEPTNO FROM DEPT WHERE DEPTNO NOT IN (SELECT DISTINCT NVL(DEPTNO, 0) FROM EMP);

-- 부서를 배정받지 못한 사원의 정보 조회
SELECT * FROM EMP WHERE DEPTNO IS NULL;

-- 부서를 배정받지 못한 직원의 부서번호, 부서명, 부서위치, 사번, 이름 정보도 같이 조회
SELECT EMP.DEPTNO, DNAME, LOC, EMPNO, ENAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO (+)
ORDER BY EMP.DEPTNO;

-- 부서원이 없는 부서의 정보도 함께 조회
SELECT DEPT.DEPTNO, DNAME, LOC, EMPNO, ENAME
FROM EMP, DEPT
WHERE EMP.DEPTNO(+) = DEPT.DEPTNO
ORDER BY EMP.DEPTNO;

-- 부서를 배정받지 못한 직원, 부서원이 없는 부서원 정보도 함께 조회 (FULL OUTER JOIN)
--  >> 오라클은 지원하지 않음 => UNION 사용
-- ERROR : ORA-01468: a predicate may reference only one outer-joined table
SELECT DEPT.DEPTNO, DNAME, LOC, EMPNO, ENAME
FROM EMP, DEPT
WHERE EMP.DEPTNO(+) = DEPT.DEPTNO(+)
ORDER BY EMP.DEPTNO;

-- 4. SELF JOIN
-- 직원의 사번, 이름, 상사 사번, 상사 이름 정보 조회
-- 직원의 사번 정렬 조회
SELECT E1.EMPNO 사번, E1.ENAME 이름, E1.MGR "상사 사번", E2.ENAME "상사 이름"
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+)
ORDER BY E1.EMPNO;

SELECT * FROM EMP;

-- 5. NON-EQUI JOIN
SELECT * FROM TAB;

DESC SALGRADE;
SELECT * FROM SALGRADE;

-- 직원의 사번, 급여, 급여등급 조회
-- 테이블 조인 : 직원, 급여등급
SELECT EMPNO, SAL, GRADE
FROM EMP, SALGRADE
WHERE SAL BETWEEN LOSAL AND HISAL;

-- 부서번호, 부서명, 사번, 이름, 급여, 급여등급 정보 조회
SELECT EMP.DEPTNO, DNAME, EMPNO, ENAME, SAL, GRADE
FROM EMP, DEPT, SALGRADE
WHERE SAL BETWEEN LOSAL AND HISAL AND EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMP.DEPTNO, EMPNO;


-- JOIN해서 VIEW 생성
-- 조회항목 : 부서번호, 부서명, 사번, 이름
-- 뷰이름 : EMP_VIEW
-- 읽기 전용
-- 1. JOIN
SELECT E.DEPTNO, D.DNAME, E.EMPNO, EMP.ENAME
FROM EMP E, DEPT E
WHERE E.DEPTNO = D.DEPTNO;

-- 2. VIEW
CREATE OR REPLACE VIEW EMP_VIEW
AS
SELECT E.DEPTNO, D.DNAME, E.EMPNO, EMP.ENAME
FROM EMP E, DEPT E
WHERE E.DEPTNO = D.DEPTNO
WITH READ ONLY;

-- 3. VIEW 조회
SELECT * FROM EMP_VIEW;



-- ANSI JOIN

-- 1. ANSI CROSS JOIN
SELECT * FROM EMP CROSS JOIN DEPT;

-- 2. ANSI EQUI JOIN
SELECT DEPTNO, DNAME, EMPNO, ENAME FROM EMP NATURAL JOIN DEPT;

SELECT DEPTNO, DNAME, EMPNO, ENAME FROM EMP JOIN DEPT USING (DEPTNO);

-- 3, ANSI OUTER JOIN

-- ANSI LEFT OUTER JOIN
-- 부서를 배정받지 못한 직원의 정보도 함께 조회
SELECT EMP.DEPTNO, DNAME, LOC, EMPNO, ENAME
FROM EMP LEFT OUTER JOIN DEPT
ON (EMP.DEPTNO = DEPT.DEPTNO);

-- ANSI RIGHT OUTER JOIN
-- 부서원이 없는 부서의 정보도 함께 조회
SELECT EMP.DEPTNO, DNAME, LOC, EMPNO, ENAME
FROM EMP RIGHT OUTER JOIN DEPT
ON (EMP.DEPTNO = DEPT.DEPTNO);

-- ANSI FULL OUTER JOIN
-- 부서를 배정받지 못한 직원의 정보, 부서원이 없는 부서의 정보도 함께 조회
SELECT EMP.DEPTNO, DNAME, LOC, EMPNO, ENAME
FROM EMP FULL OUTER JOIN DEPT
ON (EMP.DEPTNO = DEPT.DEPTNO);

-- 4. ANSI NON-EQUI JOIN
SELECT EMPNO, SAL, GRADE
FROM EMP JOIN SALGRADE
ON (SAL BETWEEN LOSAL AND HISAL);

